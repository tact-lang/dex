import "../core/liquidity-deposit.tact";
import "../core/messages.tact";

struct SwapStep {
    pool: Address;
    // Here we don't specify swapType as it is always exactIn for multihop swaps
    // therefore desiredAmount here is named minAmountOut
    minAmountOut: Int as coins;
    // Actually it is SwapStep too, but Tact doesn't support recursive structs
    nextStep: Cell? = null;
}

const SwapRequestOpcode: Int = 0xbfa68001;
struct SwapRequest {
    pool: Address;
    // If receiver is not specified, then it will be the sender of the asset
    receiver: Address?;
    params: SwapParameters;
}

struct SwapParameters {
    // false - exactIn type. True - exactOut type.
    // Note, that exactOut type doesn't support multihop swaps.
    // If you specify nextStep for exactOut swap, it will be ignored.
    isExactOutType: Bool;
    // This value is needed only for exactOut swaps.
    // This is the address, where unused tokens will be sent.
    // If the swapType is exactIn, this value is ignored.
    // If the swapType is exactOut but this value is null, then unused tokens will be sent to the swapOutReceiver.
    cashbackAddress: Address? = null;
    // If swapType is exactIn, then desiredAmount is minimal amount trader can receive
    // If swapType is exactOut, then desiredAmount is exactValue trader wants to get
    desiredAmount: Int as coins;
    // Absolute unix timestamp
    timeout: Int as uint32;
    payloadOnSuccess: Cell? = null;
    payloadOnFailure: Cell? = null;

    nextStep: SwapStep? = null;
}

const LPDepositPartOpcode: Int = 0x64c08bfc;
struct LPDepositPart {
    // TODO: We should add an option to deploy liquidity deposit contract here
    liquidityDepositContract: Address;
    additionalParams: AdditionalParams;
}

message(0x698cba08) SwapRequestTon {
    amount: Int as coins;
    action: SwapRequest;
}

message(0x1b434676) AddLiquidityPartTon {
    liquidityDepositContract: Address;
    amountIn: Int as coins;
    additionalParams: AdditionalParams;
}

trait VaultInterface {
    receive(msg: PayoutFromPool) {
        self.handlePayout(msg);
    }

    abstract fun handlePayout(msg: PayoutFromPool);
}
